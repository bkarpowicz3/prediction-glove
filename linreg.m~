function Y = linreg(features, labels, testing)
% input:    features - table of predictors where rows = time bins, cols =
% features for every channel
%           labels - table glove positions

N = 3;
M = size(features, 1);
numFeats = size(features, 2);
featsPer = 6;                   % features/channel
numChannels = numFeats/featsPer;       % assuming 6 features per channel

testM = size(testing, 1);
testR = ones(testM-N, numFeats*N+1);
if features ~= testing
    for i = 1:(testM-N+1)
        for j = 1:numChannels       % over # channels
            row = features(i:i+N-1, ((j-1)*featsPer+1):((j-1)*featsPer+featsPer))';
            row = reshape(row, 1, featsPer*N);
            idx = (j-1)*N*featsPer+2;
            testR(i, idx:idx+N*featsPer-1) = row;
        end
    end
end

R = ones(M-N, numFeats*N+1);
%for each row
for i = 1:(M-N+1)
%     row = zeros(numFeats*N);
%     row(end+1) = 1;
%     %for each feature -- should this be done on features transpose? so that
%     %it goes over time? not sure how to adapt here
%     for j = 1:size(features, 2)
%         row(end+1:end+N) = features(start:start+N-1, j);
%     end 
%     start = start + 1;
%     R(i, :) = row;
    
    % fixed pretty sure...
    for j = 1:numChannels       % over # channels
        row = features(i:i+N-1, ((j-1)*featsPer+1):((j-1)*featsPer+featsPer))';
        row = reshape(row, 1, featsPer*N);
        idx = (j-1)*N*featsPer+2;
        R(i, idx:idx+N*featsPer-1) = row;
    end
end 

a = R'*R;
ainv = a \ eye(size(a, 1)); % need to compute inverse this way or else you get Inf 
B = ainv*(R'*labels(N:end, :));

if features == testing
    Y = R*B;
else
    Y = testR*B;
end

end

